(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{513:function(t,e,a){"use strict";a.r(e);var l=a(4),v=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",[t._v("每日一记录")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/classLoad.png",alt:""}}),t._v(" "),a("img",{attrs:{src:"/img/gc.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"get的点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get的点"}},[t._v("#")]),t._v(" get的点")]),t._v(" "),a("blockquote",[a("p",[t._v("基于接口开发")])]),t._v(" "),a("ul",[a("li",[t._v("dubbo：\n"),a("blockquote",[a("p",[t._v("远程调用框架，实时调用技术，可配置，支持幂等，预警，流控等，")])]),t._v(" "),a("ul",[a("li",[t._v("使用场景：上下游系统实时依赖其处理结果，根据结果做下一步事件的场景。")]),t._v(" "),a("li",[t._v("依赖：zookeeper")]),t._v(" "),a("li",[t._v("序列化采用hessian")]),t._v(" "),a("li",[t._v("路由服务，灰度，路由脚本配置等")]),t._v(" "),a("li",[t._v("支持告警服务，短信预警、邮件预警")]),t._v(" "),a("li",[t._v("支持幂等")])]),t._v(" "),a("blockquote",[a("p",[t._v("是系统的接口对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的")])]),t._v(" "),a("ul",[a("li",[t._v("支持并发控制，流控")])]),t._v(" "),a("blockquote",[a("p",[t._v("各系统结合业务波峰被调用次数的统计向上再冗余10%或是根据压测调用次数统计来设置")])]),t._v(" "),a("ul",[a("li",[t._v("支持超时重试、超时时间配置，一般5000ms")]),t._v(" "),a("li",[t._v("权限管理")]),t._v(" "),a("li",[t._v("熔断服务")])])]),t._v(" "),a("li",[t._v("mq:消息服务，有队列和主题两种，特点：会员号进行路由，支持多活；broker分布式部署和自动发现；支持流控；动态扩容；可重试\n"),a("ul",[a("li",[t._v("使用场景：消费分发，上下游系统对处理结果弱依赖，不关心实时性，只要收到处理结果就可以了")])])])]),t._v(" "),a("h4",{attrs:{id:"中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[t._v("#")]),t._v(" 中间件：")]),t._v(" "),a("ul",[a("li",[t._v("配置管理:配置管理服务，可灵活项目配置\n"),a("ul",[a("li",[t._v("使用场景：开关配置，灰度路由配置,redis等，因业务需要或者系统性能重构而进行可控的配置化管理，文件大小小于64k")]),t._v(" "),a("li",[t._v("使用技术：依赖zk,一般容器启动时候就要初始化配置客户端，保证只加载一次，后续监听配置的变化")])]),t._v(" "),a("blockquote",[a("p",[t._v("对配置化的文件都是需要加锁的")])])]),t._v(" "),a("li",[t._v("xxl-job:定时任务服务，支持分布式")]),t._v(" "),a("li",[t._v("redis:缓存服务\n"),a("ul",[a("li",[t._v("使用场景：订单防重采用redis做的防重锁")])]),t._v(" "),a("blockquote",[a("p",[t._v("下单以后，根据单号，提交场景，以及锁定时长调用redis进行加锁，如果加锁成功则返回true,否则返回失败，流程终止，最后分布式防重 释放锁。\n下单完成之后，删除缓存的订单创建状态")])]),t._v(" "),a("ul",[a("li",[t._v("是什么?\n"),a("blockquote",[a("p",[t._v("高性能的键值，NoSql数据库，redis数据库的所有数据都存储在内存当中，内存的读写远快于硬盘")])])]),t._v(" "),a("li",[t._v("订单使用场景：1、分布式锁防重 2、缓存查oms号\n"),a("ul",[a("li",[t._v("1、分布式锁防重：jedis.set(final String key, final String value, final String nxxx,final String expx, final long time)\n"),a("ul",[a("li",[t._v("key:键")]),t._v(" "),a("li",[t._v("value:值")]),t._v(" "),a("li",[t._v("nxxx:只能取NX或者XX，如果取NX，则只有当key不存在时才进行set，如果取XX，则只有当key已经存在时才进行set")]),t._v(" "),a("li",[t._v("expx： 只能取EX或者PX，代表数据过期时间的单位，EX代表秒，PX代表毫秒。")]),t._v(" "),a("li",[t._v("time： 过期时间，单位是expx所代表的单位。")])])]),t._v(" "),a("li",[t._v("2、缓存查oms号：jedis.get(key);")])])])])])]),t._v(" "),a("h4",{attrs:{id:"一般订单流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一般订单流程"}},[t._v("#")]),t._v(" 一般订单流程：")]),t._v(" "),a("blockquote",[a("p",[t._v("协议:dubbo  流程：基础校验-订单防重-金额、库存校验-生成订单-分发下游系统")])]),t._v(" "),a("ul",[a("li",[t._v("检查订单重复性")]),t._v(" "),a("li",[t._v("检查流程引擎配置")]),t._v(" "),a("li",[t._v("并发执行“订单检查”操作")]),t._v(" "),a("li",[t._v("Executor<Target, Boolean> executor = new ConcurrentBlockingExecutor<Target, Boolean>(ExecutorServices.ABORT);")])]),t._v(" "),a("ul",[a("li",[t._v("支付:")])]),t._v(" "),a("blockquote",[a("p",[t._v("协议:dubbo  流程：校验-在线支付处理防重锁（根据场景关键key调redis的java封装的setnx方法进行加锁，加锁成功为true）-支付处理（支持多线程，如果多单则进行拆分分组）- 分布式锁（DistributedOrderLocks锁单号，指定时间秒级别，最后再释放）-支付加锁防止与取消操作冲突-支付信息保存-分发下游系统-释放支付处理防重锁")])]),t._v(" "),a("h4",{attrs:{id:"多线程使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程使用"}},[t._v("#")]),t._v(" 多线程使用")]),t._v(" "),a("ul",[a("li",[t._v("线程池")])]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public ThreadPoolExecutor(int corePoolSize,  //核心线程池数\n                              int maximumPoolSize, //最大线程池数\n                              long keepAliveTime, //存活时长\n                              TimeUnit unit, //单位，一般为秒\n                              BlockingQueue<Runnable> workQueue, //队列类型\n                              ThreadFactory threadFactory, //线程工厂\n                              RejectedExecutionHandler handler// 拒绝策略\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("ul",[a("li",[t._v("订单提交\n"),a("ul",[a("li",[t._v("同步外围系统时候，因为处理业务量大一单可能包含很多行，原来单线程处理耗时比较严重，后续改为多线程，对一单多行的单子进行拆分执行")])])])]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('       /** 线程 */\n       public static final ThreadPoolExecutor DEMO_EXECUTOR = new ThreadPoolExecutor(10, 100, 60, TimeUnit.SECONDS,\n                new ArrayBlockingQueue<Runnable>(300), new BasicThreadFactory("NameExecutor"), new CallerRunsPolicy());\n\n\n       private void getDemo(final order order) {\n            if (order.getList().size() <= 10) {\n               // 处理\n            } else {\n                new Executor<Ordi>(order, 10, ExecutorServices.DEMO_EXECUTOR) {\n                   @Override\n                   protected void callback(order order) {\n                       system.out.print(order)\n                   }\n               }.execute();\n            }\n        }\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br")])]),a("ul",[a("li",[a("p",[t._v("分发外围")])]),t._v(" "),a("li",[a("p",[t._v("压测")])]),t._v(" "),a("li",[a("p",[t._v("定时任务")])])]),t._v(" "),a("h4",{attrs:{id:"线程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[t._v("#")]),t._v(" 线程状态")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。\n线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。")])])]),t._v(" "),a("li",[t._v("3.阻塞(BLOCKED)：表示线程阻塞于锁。")]),t._v(" "),a("li",[t._v("4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。")]),t._v(" "),a("li",[t._v("5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。")]),t._v(" "),a("li",[a("ol",{attrs:{start:"6"}},[a("li",[t._v("终止(TERMINATED)：表示该线程已经执行完毕")])])])]),t._v(" "),a("h4",{attrs:{id:"队列积压"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列积压"}},[t._v("#")]),t._v(" 队列积压")]),t._v(" "),a("ul",[a("li",[t._v("案列\n"),a("ul",[a("li",[t._v("索引未建，导致sql执行慢，队列积压，解决方案：重建索引")]),t._v(" "),a("li",[t._v("数据量大，频繁操作数据库；解决方案：数据库读写分离")]),t._v(" "),a("li",[t._v("数据量大；解决方案：启动多线程跑")]),t._v(" "),a("li",[t._v("数据量大；解决方案：调快定时任务")])])])]),t._v(" "),a("h4",{attrs:{id:"oom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oom"}},[t._v("#")]),t._v(" OOM")]),t._v(" "),a("ul",[a("li",[t._v("案列\n"),a("img",{attrs:{src:"/img/t1.png",alt:""}}),t._v(" "),a("ul",[a("li",[t._v("数据库执行大量sql，导致oom；解决方案：调小执行脚本数")]),t._v(" "),a("li",[t._v("多线程使用中未对其配置拒绝策略")])]),t._v(" "),a("blockquote",[a("p",[t._v("OOM的版本使用了这个ExecutorService.newFixedThreadPool 中执行线程的个数，我们将线程池的数量设置为10个。\n对于java.util.concurrent.Executors所提供的FixedThreadPool，可以保证可以在内存中有固定数量的线程数运行。但是由于FixedThreadPool绑定的是LinkedBlockingQueue。队列的上限没有限制（默认上限为Integer.MAX_VALUE），不断的提交新的线程，会造成任务在内存中长时间的堆积。")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("针对当前情况，我们需要为线程池添加相应的拒绝策略")]),t._v(" "),a("ul",[a("li",[t._v("AbortPolicy策略:")])]),t._v(" "),a("blockquote",[a("p",[t._v("该策略直接抛出异常，中止系统工作")])]),t._v(" "),a("ul",[a("li",[t._v("CallerRunsPolicy策略：")])]),t._v(" "),a("blockquote",[a("p",[t._v("只要线程池未关闭，该策略直接在调用线程中运行当前被丢弃的任务。\n虽然这样不会真正的丢弃任务，但是调用者线程性能可能急剧下降。")])]),t._v(" "),a("ul",[a("li",[t._v("DiscardOledestPolicy策略：")])]),t._v(" "),a("blockquote",[a("p",[t._v("丢弃最老的一个请求任务，也就是丢弃一个即将被执行的任务，并尝试再次提交当前任务。")])]),t._v(" "),a("ul",[a("li",[t._v("DiscardPolicy策略：")])]),t._v(" "),a("blockquote",[a("p",[t._v("默默的丢弃无法处理的任务，不予任何处理。")])])]),t._v(" "),a("li",[a("p",[t._v("在以后进行编码的过程中，要充分考虑到系统资源的占用情况，尽可能的使用占用资源少的策略")])])])])]),t._v(" "),a("h4",{attrs:{id:"容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[t._v("#")]),t._v(" 容器")]),t._v(" "),a("blockquote",[a("p",[t._v("容器：由镜像创建的运行实例，类似虚拟机，每个容器间是相互隔离的，容器中会运行特定的应用,可以把容器看做是一个简易版的 Linux 环境和运行在其中的应用程序")])]),t._v(" "),a("h4",{attrs:{id:"jvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[t._v("#")]),t._v(" JVM")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/jvm.png",alt:""}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("回收机制")]),t._v(" "),a("ul",[a("li",[t._v("标记清除法\n"),a("blockquote",[a("p",[t._v("每个对象存储一个标记位，记录对象的状态：生存或者死亡")])])]),t._v(" "),a("li",[t._v("引用计数法\n"),a("blockquote",[a("p",[t._v("计数为0时候，表示没有调用，则回收")])])]),t._v(" "),a("li",[t._v("标记整理法")]),t._v(" "),a("li",[t._v("复制法")]),t._v(" "),a("li",[t._v("分代收集法")])]),t._v(" "),a("blockquote",[a("p",[t._v("分新生代和老年代")])])]),t._v(" "),a("li",[a("p",[t._v("共享区")]),t._v(" "),a("ul",[a("li",[t._v("方法区 ：类信息、常量、静态变量")]),t._v(" "),a("li",[t._v("堆 ：实例对象")]),t._v(" "),a("li",[t._v("堆 ：直接内存")])])]),t._v(" "),a("li",[a("p",[t._v("私有区")]),t._v(" "),a("ul",[a("li",[t._v("本地方法栈")]),t._v(" "),a("li",[t._v("程数计数器")]),t._v(" "),a("li",[t._v("虚拟机栈")])])])]),t._v(" "),a("h4",{attrs:{id:"多核下线程数量选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多核下线程数量选择"}},[t._v("#")]),t._v(" 多核下线程数量选择")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. 计算密集型\n计算密集型任务指的是程序主要为复杂的逻辑判断和复杂的运算。\n\n计算密集型任务的CPU利用率高，不用开太多的线程，开太多线程反而会因为线程切换时切换上下文而浪费资源。\n\n一般来说，计算密集型任务，线程数量可以参考为  ，其中n为CPU的逻辑核心数量。\n\n2. IO密集型\nIO密集型任务指的是程序主要为IO操作，比如磁盘IO(读取文件)和网络IO(网络请求)。\n\n因为IO操作会长时间阻塞线程，cpu利用率不高，可以开多点线程，阻塞时可以切换到其他就绪线程，提高CPU利用率。\n\n一般来说，计算密集型任务，线程数量可以参考为  ，其中n为CPU的逻辑核心数量。\n")])])]),a("h4",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期"),a("br")]),t._v(" "),a("blockquote",[a("p",[t._v("生命周期：对于人是从出生到回归，对于软件程序：是初始化到服务期间、再到销毁")])]),t._v(" "),a("h4",{attrs:{id:"datetime和timestamp的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#datetime和timestamp的区别"}},[t._v("#")]),t._v(" datetime和timestamp的区别？")]),t._v(" "),a("ul",[a("li",[t._v("时间范围不同")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("datetime")]),t._v(" "),a("th",{staticStyle:{"text-align":"right"}},[t._v("“1000-01-01 00:00:00” ~ “9999-12-31 23:59:59”（和时区无关，怎么存入怎么返回，对程序员友好）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("timestamp")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("“1970-01-01 00:00:01” UTC ~ “2038-01-19 03:14:07” （和时区有关）")])])])]),t._v(" "),a("ul",[a("li",[t._v("datetime类型使用8个字节来表示日期和时间。")]),t._v(" "),a("li",[t._v("datetime （推荐甚至强制要求必须）‘YYYY-MM-DD HH:MM:SS’或‘YYYYMMDDHHMMSS’格式的字符串表示")]),t._v(" "),a("li",[t._v("timestamp类型使用4个字节来表示日期和时间。")]),t._v(" "),a("li",[t._v("timestamp类型还有一个很大的特殊点，就是时间是根据时区来显示的。")])]),t._v(" "),a("blockquote",[a("p",[t._v("例如，在东八区插入的timestamp类型为2009-09-30 14:21:25，在东七区显示时，时间部门就变成了13:21:25，在东九区显示时，时间部门就变成了15:21:25。\n需要显示日期与时间，timestamp类型需要根据不同地区的时区来转换时间，但是，timestamp类型的范围太小，其最大时间为2038-01-19 11:14:07。\n如果插入时间的比这个大，将会数据库插入0000-00-00 00:00:00。所以需要的时间范围比较大，还是选择dateTime类型比较安全")])]),t._v(" "),a("h4",{attrs:{id:"decimal-16-4-含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decimal-16-4-含义"}},[t._v("#")]),t._v(" decimal（16，4）含义？")]),t._v(" "),a("blockquote",[a("p",[t._v("长度为16（包含小数点），小数点4位；")])]),t._v(" "),a("h4",{attrs:{id:"java的char一定是2个字节吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的char一定是2个字节吗"}},[t._v("#")]),t._v(" Java的char一定是2个字节吗？")]),t._v(" "),a("blockquote",[a("p",[t._v("不一定，与我们使用的字符集有关系，如果使用ASCII编码集，那么char占用一个字节，如果使用UTF-8编码格式呢？UTF-8是不定长编码，编码的长度是动态的，所以不一定。\nchar能存储中文吗？\n这个问题依旧归结于使用的编码集，如果使用ASCII，那肯定不能存储，如果采用UTF-8，那可以。\nchar的长度和是否能存储中文字符是和编码格式有关的。对于我们在编码的时候如果跨平台编码时，应该在编码、解码的时候设置对应的格式，防止由于编解码导致的异常。")])]),t._v(" "),a("h3",{attrs:{id:"索引文件存储的是什么内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引文件存储的是什么内容"}},[t._v("#")]),t._v(" 索引文件存储的是什么内容？")]),t._v(" "),a("blockquote",[a("p",[t._v("数据库中带有索引表的文件。由索引与文件本身两部分组成。\n其中的索引按关键字大小顺序排列。记录区按关键字顺序排列的称为索引顺序文件;\n记录区不按关键字顺序排列的称为索引非顺序文件。\n索引文件的存储分两个区：索引区和数据区。\n文件建立时，自动开辟索引区。按记录进入顺序登 记索引项。\n最后将索引区按关键字的递增或递减排列。\n在索引文件中根据关键字检索一个记录时，应分两步进行。\n首先，查看索引，将外存上索引块送入内存，根据关键字查找索引项，得到所要找的记录地址。\n然后，根据记录地址读取该记录。\n建立索引文件的目的主要是加快对各类信息的查询速度，尤其是存取大批量的随机数据时效果最明显。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);