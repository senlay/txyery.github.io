(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{581:function(t,e,a){"use strict";a.r(e);var l=a(4),i=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"服务器端负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器端负载均衡"}},[t._v("#")]),t._v(" 服务器端负载均衡")]),t._v(" "),a("blockquote",[a("p",[t._v("负载均衡是我们处理高并发、缓解网络压力和进行服务器扩容的重要手段之一，但是一般情况下我们所说的负载均衡通常都是指服务器端负载均衡，服务器端负载均衡又分为两种，一种是硬件负载均衡，还有一种是软件负载均衡")])]),t._v(" "),a("h4",{attrs:{id:"客户端负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端负载均衡"}},[t._v("#")]),t._v(" 客户端负载均衡")]),t._v(" "),a("blockquote",[a("p",[t._v("而微服务的出现，则为负载均衡的实现提供了另外一种思路：把负载均衡的功能以库的方式集成到服务的消费方，而不再是由一台指定的负载均衡设备集中提供。这种方案称为软负载均衡（Soft Load Balancing）或者客户端负载均衡。常见的如：Spring Cloud中的 Ribbon。")])]),t._v(" "),a("h4",{attrs:{id:"ribbon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ribbon"}},[t._v("#")]),t._v(" Ribbon")]),t._v(" "),a("ul",[a("li",[t._v("Ribbon是一个基于HTTP和TCP的客户端负载均衡器，当我们将Ribbon和Eureka一起使用时，Ribbon会到Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用，客户端负载均衡也需要心跳机制去维护服务端清单的有效性，当然这个过程需要配合服务注册中心一起完成。")]),t._v(" "),a("li",[t._v("Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。")]),t._v(" "),a("li",[t._v("Ribbon是Netflix发布的开源顶目，主要功能是提供客户端的软件负均衡算法，将Netflix的中间层服务连接在一起。Ribbon窖户端组件提供一系列完善配置项如连接超时，重试等。简軍的说，就是在配置文件中列出LoadBalancer〔简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（筒单轮洵，随机连接等）去连接这些机器。我们也很容易使Ribbon实现自定义负载均衡算法·\n#####服务器端负载均衡 VS 客户端负载均衡的特点如下：")]),t._v(" "),a("li",[t._v("服务器端负载均衡 客户端先发送请求到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求。")]),t._v(" "),a("li",[t._v("客户端负载均衡 客户端自己维护一个可用服务器地址列表，在发送请求前先通过负载均衡算法选择一个将用来处理本次请求的服务器，然后再直接将请求发送至该服务器。")])]),t._v(" "),a("h4",{attrs:{id:"什么是loadbalancer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是loadbalancer"}},[t._v("#")]),t._v(" 什么是LoadBalancer？")]),t._v(" "),a("blockquote",[a("p",[t._v("LB，即负载均衡（L。adBalance),在微服务或分布式集群中经常比的一种应用·\n负载均衡简单的说就是将用户的满求平滩的分配到多个务上，从而达到系统的HA。\n常见的负载均衡有件Nginx，CVS,硬件F5等·\n相应的在中间件，例如：dubbo和SpringCIoud中均给我们供了负载均衡。springcloud的负载均衡算法可以自定义。")])]),t._v(" "),a("ul",[a("li",[t._v("集中式LB\n"),a("ul",[a("li",[t._v("即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方。")])])]),t._v(" "),a("li",[t._v("进程内LB\n"),a("ul",[a("li",[t._v("将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择一个合适的服务器。")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("Ribbon就属于进程内LB，它是一个类库，集成与消费方进程，消费方通过它来获取到服务器提供方的地址。")])]),t._v(" "),a("h4",{attrs:{id:"resttemplate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resttemplate"}},[t._v("#")]),t._v(" RestTemplate")]),t._v(" "),a("blockquote",[a("p",[t._v("RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法。我们需要编写一个RestTemplate 配置类。")])]),t._v(" "),a("h4",{attrs:{id:"负载均衡的策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡的策略"}},[t._v("#")]),t._v(" 负载均衡的策略")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("RoundRobinRule: 轮询策略，Ribbon以轮询的方式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问;")])]),t._v(" "),a("li",[a("p",[t._v("RandomRule: 随机策略，也就是说Ribbon会随机从服务器列表中选择一个进行访问;")])]),t._v(" "),a("li",[a("p",[t._v("BestAvailableRule: 最大可用策略，即先过滤出故障服务器后，选择一个当前并发请求数最小的;")])]),t._v(" "),a("li",[a("p",[t._v("WeightedResponseTimeRule: 带有加权的轮询策略，对各个服务器响应时间进行加权处理，然后在采用轮询的方式来获取相应的服务器;")])]),t._v(" "),a("li",[a("p",[t._v("AvailabilityFilteringRule: 可用过滤策略，先过滤出故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个;")])]),t._v(" "),a("li",[a("p",[t._v("ZoneAvoidanceRule: 区域感知策略，先使用主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例清单，依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤，判断最小过滤数（默认1）和最小过滤百分比（默认0），最后对满足条件的服务器则使用RoundRobinRule(轮询方式)选择一个服务器实例。")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);