(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{528:function(a,e,t){"use strict";t.r(e);var n=t(4),r=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h4",{attrs:{id:"java-thread-dump分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-thread-dump分析"}},[a._v("#")]),a._v(" Java Thread Dump分析")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("任何操作系统平台下都可以使用。")])]),a._v(" "),t("li",[t("p",[a._v("在多数情况下，可以在生产环境中使用。")])]),a._v(" "),t("li",[t("p",[a._v("和操作系统提供的工具相比，java thread dump给出的信息是直白的，直接对应到应用代码。")])]),a._v(" "),t("li",[t("p",[a._v("它对被分析的系统干扰很小，因此能反应真实的问题。而其它很多profiling或Instrument工具本身对JVM运行有很大的干扰，经常不能暴露出真正的问题，而且这种工具不能用于生产系统。")])])]),a._v(" "),t("h4",{attrs:{id:"java-线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-线程"}},[a._v("#")]),a._v(" Java 线程")]),a._v(" "),t("p",[a._v("线程是指能独立于程序的其它部分运行的执行单元。 JAVA语言能够很好的实现多线程的程序。我们在调试程序，或者在开发后期需要做性能调优的时候，往往也需要了解当前程序正在运行的线程的状态，正在执行的操作，从而分析系统可能存在的问题。")]),a._v(" "),t("h4",{attrs:{id:"产生-java线程-dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#产生-java线程-dump"}},[a._v("#")]),a._v(" 产生 JAVA线程 dump")]),a._v(" "),t("p",[a._v("JAVA 的线程 DUMP，就象当前 JAVA进程的一个快照，打印出所有线程的状态和调用堆栈，以及 Monitor的状态。在不同的操作系统下，产生线程 DUMP的方式是不同的。")]),a._v(" "),t("h4",{attrs:{id:"windows"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#windows"}},[a._v("#")]),a._v(" windows")]),a._v(" "),t("p",[a._v("在启动程序的控制台里敲： Ctrl - Break，线程的 dump会产生在标准输出中（缺省标准输出就是控制台，如果对输出进行了重定向，则要查看输出文件）。")]),a._v(" "),t("p",[a._v("Linux(Unix\\MacOS)\n用 “kill -3 "),t("pid",[a._v("” ，或者 “kill – QUIT "),t("pid",[a._v("”。 Pid是用所关注的 JAVA进程号，您可以用 “ps -ef | grep java” 找到，或者使用 JDK 5.0(或以上)中的 “jps -v” 命令获得。")])],1)],1),a._v(" "),t("p",[a._v("在各个操作系统平台，都可以用 JDK 5.0(或以上)工具包中的 jstack "),t("pid")],1),a._v(" "),t("p",[a._v("这里要注意的是：")]),a._v(" "),t("ol",[t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("不同的 JAVA虚机的线程 DUMP的创建方法和文件格式是不一样的，不同的 JVM版本， dump信息也有差别。\n")])])])]),a._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("在实际运行中，往往一次 dump的信息，还不足以确认问题。建议产生二到三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。\n")])])])])]),a._v(" "),t("p",[a._v("线程的状态分析\n线程的状态是一个重要的指标，它会显示在线程 Stacktrace的头一行结尾的地方。那么线程常见的有哪些状态呢？线程在什么样的情况下会进入这种状态呢？我们能从中发现什么线索？")]),a._v(" "),t("p",[a._v("dump 文件里，值得关注的线程状态有：\n死锁，Deadlock（重点关注）\n执行中，Runnable\n等待资源，Waiting on condition（重点关注）\n等待获取监视器，Waiting on monitor entry（重点关注）\n暂停，Suspended\n对象等待中，Object.wait() 或 TIMED_WAITING\n阻塞，Blocked（重点关注）\n停止，Parked\nDeadlock\n死锁线程，一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。")]),a._v(" "),t("p",[a._v("Runnable\n该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。")]),a._v(" "),t("p",[a._v("Waiting on condition\n等待资源，或等待某个条件的发生。具体原因需结合 stacktrace来分析。")]),a._v(" "),t("p",[a._v("如果堆栈信息明确是应用代码，则证明该线程正在等待资源。一般是大量读取某资源，且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取。\n又或者，正在等待其他线程的执行等。\n如果发现有大量的线程都在处在 Wait on condition，从线程 stack看，正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。\n一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；\n另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。\n另外一种出现 Wait on condition的常见情况是该线程在 sleep，等待 sleep的时间到了时候，将被唤醒。\nBlocked\n线程阻塞，是指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。")]),a._v(" "),t("p",[a._v("Waiting for monitor entry 和 in Object.wait()\nMonitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。从下图1中可以看出，每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("                                                          图1\n")])])]),t("p",[a._v("先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像：")]),a._v(" "),t("p",[a._v("synchronized(obj) {")]),a._v(" "),t("p",[a._v(".........")]),a._v(" "),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("这时有两种可能性：")]),a._v(" "),t("p",[a._v("·          该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码")]),a._v(" "),t("p",[a._v("·          该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。")]),a._v(" "),t("p",[a._v("在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。如下所示：")]),a._v(" "),t("p",[a._v('"Thread-0" prio=10 tid=0x08222eb0 nid=0x9 waiting for monitor entry [0xf927b000..0xf927bdb8]')]),a._v(" "),t("p",[a._v("at testthread.WaitThread.run(WaitThread.java:39)")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("waiting to lock <0xef63bf08> (a java.lang.Object)")])]),a._v(" "),t("li",[t("p",[a._v("locked <0xef63beb8> (a java.util.ArrayList)")])])]),a._v(" "),t("p",[a._v("at java.lang.Thread.run(Thread.java:595)")]),a._v(" "),t("p",[a._v("临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。 如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。")]),a._v(" "),t("p",[a._v("现在我们再来看现在线程为什么会进入 “Wait Set”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ， “ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()，类似于：")]),a._v(" "),t("p",[a._v('"Thread-1" prio=10 tid=0x08223250 nid=0xa in Object.wait() [0xef47a000..0xef47aa38]')]),a._v(" "),t("p",[a._v("at java.lang.Object.wait(Native Method)")]),a._v(" "),t("ul",[t("li",[a._v("waiting on <0xef63beb8> (a java.util.ArrayList)")])]),a._v(" "),t("p",[a._v("at java.lang.Object.wait(Object.java:474)")]),a._v(" "),t("p",[a._v("at testthread.MyWaitThread.run(MyWaitThread.java:40)")]),a._v(" "),t("ul",[t("li",[a._v("locked <0xef63beb8> (a java.util.ArrayList)")])]),a._v(" "),t("p",[a._v("at java.lang.Thread.run(Thread.java:595)")]),a._v(" "),t("p",[a._v("仔细观察上面的 DUMP信息，你会发现它有以下两行：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("locked <0xef63beb8> (a java.util.ArrayList)")])]),a._v(" "),t("li",[t("p",[a._v("waiting on <0xef63beb8> (a java.util.ArrayList)")])])]),a._v(" "),t("p",[a._v("这里需要解释一下，为什么先 lock了这个对象，然后又 waiting on同一个对象呢？让我们看看这个线程对应的代码：")]),a._v(" "),t("p",[a._v("synchronized(obj) {")]),a._v(" "),t("p",[a._v(".........")]),a._v(" "),t("p",[a._v("obj.wait();")]),a._v(" "),t("p",[a._v(".........")]),a._v(" "),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked <0xef63beb8> ）。当执行到 obj.wait(), 线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on <0xef63beb8> ）。")]),a._v(" "),t("p",[a._v("往往在你的程序中，会出现多个类似的线程，他们都有相似的 DUMP信息。这也可能是正常的。比如，在程序中，有多个服务线程，设计成从一个队列里面读取请求数据。这个队列就是 lock以及 waiting on的对象。当队列为空的时候，这些线程都会在这个队列上等待，直到队列有了数据，这些线程被 Notify，当然只有一个线程获得了 lock，继续执行，而其它线程继续等待。")]),a._v(" "),t("p",[a._v('综合范例\n综合示范一： Deadlock\n拿到java thread dump后，你要做的就是查找"waiting for monitor entry"的thread，如果大量thread都在等待给同一个地址上锁（因为对于Java，一个对象只有一把锁），这说明很可能死锁发生了。比如：')]),a._v(" "),t("p",[a._v('"service-j2ee" prio=5 tid=0x024f1c28 nid=0x125 waiting for monitor entry')]),a._v(" "),t("p",[a._v("[62a3e000..62a3f690]")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool.internalGetResource(IASNonS")]),a._v(" "),t("p",[a._v("haredResourcePool.java:625)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - waiting to")]),a._v(" "),t("p",[a._v("lock <0x965d8110> (a com.sun.enterprise.resource.IASNonSharedResourcePool)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool.getResource(IASNonSharedRes")]),a._v(" "),t("p",[a._v("ourcePool.java:520)")]),a._v(" "),t("p",[a._v("................")]),a._v(" "),t("p",[a._v("为了确定问题，常常需要在隔两分钟后再次收集一次thread dump，如果得到的输出相同，仍然是大量thread都在等待给同一个地址上锁，那么肯定是死锁了。")]),a._v(" "),t("p",[a._v('如何找到当前持有锁的线程是解决问题的关键。方法是搜索thread dump，查找"locked <0x965d8110>"， 找到持有锁的线程。')]),a._v(" "),t("p",[a._v('[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: "Thread-20" daemon prio=5 tid=0x01394f18')]),a._v(" "),t("p",[a._v("nid=0x109 runnable [6716f000..6716fc28]")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("java.net.SocketInputStream.socketRead0(Native Method)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("java.net.SocketInputStream.read(SocketInputStream.java:129)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at oracle.net.ns.Packet.receive(Unknown")]),a._v(" "),t("p",[a._v("Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: a")]),a._v(" "),t("p",[a._v("oracle.net.ns.DataPacket.receive(Unknown Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.net.ns.NetInputStream.getNextPacket(Unknown Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.net.ns.NetInputStream.read(Unknown Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.net.ns.NetInputStream.read(Unknown Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: a")]),a._v(" "),t("p",[a._v("oracle.net.ns.NetInputStream.read(Unknown Source)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.jdbc.ttc7.MAREngine.unmarshalUB1(MAREngine.java:929)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.jdbc.ttc7.MAREngine.unmarshalSB1(MAREngine.java:893)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.jdbc.ttc7.Ocommoncall.receive(Ocommoncall.java:106)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.jdbc.ttc7.TTC7Protocol.logoff(TTC7Protocol.java:396)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked <0x954f47a0> (a")]),a._v(" "),t("p",[a._v("oracle.jdbc.ttc7.TTC7Protocol)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("oracle.jdbc.driver.OracleConnection.close(OracleConnection.java:1518)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked <0x954f4520> (")]),a._v(" "),t("p",[a._v("oracle.jdbc.driver.OracleConnection)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.JdbcUrlAllocator.destroyResource(JdbcUrlAllocator.java:122)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool.destroyResource(IASNonSharedResourcePool.java:8")]),a._v(" "),t("ol",{attrs:{start:"72"}},[t("li")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool.resizePool(IASNonSharedResourcePool.java:1086)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked <0x965d8110> (a")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("com.sun.enterprise.resource.IASNonSharedResourcePool$Resizer.run(IASNonSharedResourcePool.java:1178)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("java.util.TimerThread.mainLoop(Timer.java:432)")]),a._v(" "),t("p",[a._v("[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at")]),a._v(" "),t("p",[a._v("java.util.TimerThread.run(Timer.java:382)")]),a._v(" "),t("p",[a._v("在这个例子里，持有锁的线程在等待Oracle返回结果，却始终等不到响应，因此发生了死锁。")]),a._v(" "),t("p",[a._v("如果持有锁的线程还在等待给另一个对象上锁，那么还是按上面的办法顺藤摸瓜，直到找到死锁的根源为止。")]),a._v(" "),t("p",[a._v('注：第一行里"service-j2ee"是 Thread Name 。tid指Java Thread id。nid指native线程的id。prio是线程优先级。[62a3e000..62a3f690]是线程栈起始地址。')]),a._v(" "),t("p",[a._v('综合示范二：Waiting to lock 和 Blocked\n"RMI TCP Connection(267865)-172.16.5.25" daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat org.apache.log4j.Category.callAppenders(Category.java:201)')]),a._v(" "),t("ul",[t("li",[a._v('waiting to lock <0x00000000acf4d0c0> (a org.apache.log4j.Logger)\nat org.apache.log4j.Category.forcedLog(Category.java:388)\nat org.apache.log4j.Category.log(Category.java:853)\nat org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)\nat com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)\n……\n1）线程状态是 Blocked，阻塞状态。说明线程等待资源超时！\n2）“ waiting to lock <0x00000000acf4d0c0>”指，线程在等待给这个 0x00000000acf4d0c0 地址上锁。\n3）在 dump 日志里查找字符串 0x00000000acf4d0c0，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如locked < 0x00000000acf4d0c0 >），就可以顺藤摸瓜了。\n4）“waiting for monitor entry”说明此线程通过 synchronized(obj) {……} 申请进入了临界区，从而进入了上图1中的“Entry Set”队列，但该 obj 对应的 monitor 被其他线程拥有，所以本线程在 Entry Set 队列中等待。\n综合示范三：Waiting on condition 和 TIMED_WAITING\n"RMI TCP Connection(idle)" daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]\njava.lang.Thread.State: TIMED_WAITING (parking)\nat sun.misc.Unsafe.park(Native Method)')]),a._v(" "),t("li",[a._v("parking to wait for  <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack)\nat java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)\nat java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)\nat java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)\nat java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)\nat java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)\nat java.lang.Thread.run(Thread.java:662)\n1）“TIMED_WAITING (parking)”中的 timed_waiting 指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。\n2）“waiting on condition”需要与堆栈中的“parking to wait for  <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack)”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue 并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。\n综合示范四：in Obejct.wait() 和 TIMED_WAITING")])]),a._v(" "),t("p",[a._v('"RMI RenewClean-[172.16.5.19:28475]" daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]\njava.lang.Thread.State: TIMED_WAITING (on object monitor)\nat java.lang.Object.wait(Native Method)')]),a._v(" "),t("ul",[t("li",[a._v("waiting on <0x00000000aa672478> (a java.lang.ref.ReferenceQueue$Lock)\nat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)")]),a._v(" "),t("li",[a._v("locked <0x00000000aa672478> (a java.lang.ref.ReferenceQueue$Lock)\nat sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)\nat java.lang.Thread.run(Thread.java:662)\n1）“TIMED_WAITING (on object monitor)”，对于本例而言，是因为本线程调用了 java.lang.Object.wait(long timeout) 而进入等待状态。\n2）“Wait Set”中等待的线程状态就是“ in Object.wait() ”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ，“ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。\n3）RMI RenewClean 是 DGCClient 的一部分。DGC指的是 Distributed GC，即分布式垃圾回收。\n4）从堆栈信息看，是正在清理 remote references to remote objects ，引用的租约到了，分布式垃圾回收在逐一清理呢。\n具体实例\n根据以上分析：")])]),a._v(" "),t("p",[a._v("每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。")]),a._v(" "),t("p",[a._v("在 “ Entry Set”里面的线程都等待拿到Monitor，拿到了线程就成为了Runnable线程，否则就会一直处于处于 “waiting for monitor entry”。以下一段代码作为例子：")]),a._v(" "),t("p",[a._v("public class MyThread implements Runnable{")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v(' public void run() {\n\n     synchronized(this) {\n\n          for (int i = 0; i < 1; i--) {\n\n               System.out.println(Thread.currentThread().getName() + " synchronized loop " + i);\n\n          }\n\n     }\n\n}\n\npublic static void main(String[] args) {\n\n    MyThread t1 = new MyThread();\n\n     Thread ta = new Thread(t1, "A");\n\n     Thread tb = new Thread(t1, "B");\n\n     ta.start();\n\n     tb.start();\n\n}\n')])])]),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("从代码我们可以看出，B线程肯定是永远拿不到Monitor了。")]),a._v(" "),t("p",[a._v("在linux系统环境下运行，使用 ps -ef | grep java 获取执行该代码的进程号，然后使用JDK自带工具jstak生成dump文件，如下图所示：")]),a._v(" "),t("p",[a._v("此时，就会将dump文件输出到当前目录，并以a.txt命名，以下是内容：")]),a._v(" "),t("p",[a._v('"B" prio=10 tid=0x0969a000 nid=0x11d6 waiting for monitor entry [0x8bb22000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat org.marshal.MyThread.run(MyThread.java:7)\n- waiting to lock <0x94757078> (a org.marshal.MyThread)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v('"A" prio=10 tid=0x09698800 nid=0x11d5 runnable [0x8bb73000]\njava.lang.Thread.State: RUNNABLE\nat java.io.FileOutputStream.writeBytes(Native Method)\nat java.io.FileOutputStream.write(FileOutputStream.java:297)\nat java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)\nat java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)\n- locked <0x947571b0> (a java.io.BufferedOutputStream)\nat java.io.PrintStream.write(PrintStream.java:449)\n- locked <0x94757190> (a java.io.PrintStream)\nat sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:220)\nat sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:290)\nat sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:103)\n- locked <0x947572a0> (a java.io.OutputStreamWriter)\nat java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)\nat java.io.PrintStream.write(PrintStream.java:494)\n- locked <0x94757190> (a java.io.PrintStream)\nat java.io.PrintStream.print(PrintStream.java:636)\nat java.io.PrintStream.println(PrintStream.java:773)\n- locked <0x94757190> (a java.io.PrintStream)\nat org.marshal.MyThread.run(MyThread.java:8)\n- locked <0x94757078> (a org.marshal.MyThread)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v("<0x94757078> 就是两个线程争夺的Monitor。")]),a._v(" "),t("p",[a._v("在 “Wait Set”里面的线程都如饥似渴地等待拿到Monitor。他们是怎么进入到“Wait Set”的呢？当一个线程拿到了Monitor，但是在其他资源没有到位的情况下，调用同步锁对象（一般是synchronized()内的对象）的 wait() 方法，放弃了 Monitor，它就进入到了 “Wait Set”队列。只有当其他线程通过notify() 或者 notifyAll()，释放了同步锁后，这个线程才会有机会重新去竞争Monitor。在stack中，它表现的状态是in Object.wait()。修改上面的代码如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v(" public void run() {\n\n    synchronized(this) {\n\n        try {\n\n            this.wait();\n\n        } catch (InterruptedException e) {\n\n            // TODO Auto-generated catch block\n\n            e.printStackTrace();\n\n        }\n\n    }\n")])])]),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("public static void main(String[] args) {")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('    WaitThread t1 = new WaitThread();\n\n    Thread ta = new Thread(t1, "A");\n\n    Thread tb = new Thread(t1, "B");\n\n    ta.start();\n\n    tb.start();\n')])])]),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("以相同的方法获得dump文件，内容如下：")]),a._v(" "),t("p",[a._v('"B" prio=10 tid=0x08173000 nid=0x1304 in Object.wait() [0x8baf2000]\njava.lang.Thread.State: WAITING (on object monitor)\nat java.lang.Object.wait(Native Method)\n- waiting on <0xa9cb50e0> (a org.marshal.WaitThread)\nat java.lang.Object.wait(Object.java:502)\nat org.marshal.WaitThread.run(WaitThread.java:8)\n- locked <0xa9cb50e0> (a org.marshal.WaitThread)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v('"A" prio=10 tid=0x08171c00 nid=0x1303 in Object.wait() [0x8bb43000]\njava.lang.Thread.State: WAITING (on object monitor)\nat java.lang.Object.wait(Native Method)\n- waiting on <0xa9cb50e0> (a org.marshal.WaitThread)\nat java.lang.Object.wait(Object.java:502)\nat org.marshal.WaitThread.run(WaitThread.java:8)\n- locked <0xa9cb50e0> (a org.marshal.WaitThread)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v("A和B线程都进入了”wait set“。B线程也拿到过这个Monitor，因为A线程释放过了，这也验证上面的话，他们都在等待得而复失的<0xa9cb50e0>。")]),a._v(" "),t("p",[a._v("基于我们经常讨论到的死锁问题，构造一段代码如下")]),a._v(" "),t("p",[a._v("public class DeadThread implements Runnable{")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('private Object monitor_A = new Object();\n\nprivate Object monitor_B = new Object();\n\npublic void  method_A(){\n\n     synchronized(monitor_A) {\n\n           synchronized(monitor_B) {\n\n               System.out.println(Thread.currentThread().getName()+" invoke method A");\n\n           }\n\n       }\n\n}\n\npublic void  method_B(){\n\n     synchronized(monitor_B) {\n\n           synchronized(monitor_A) {\n\n               System.out.println(Thread.currentThread().getName()+" invoke method B");\n\n           }\n\n       }\n\n}\n\npublic void run() {\n\n    for(int i=0;i<1;i--){\n\n        method_A();\n\n        method_B();\n\n    }\n\n}\n')])])]),t("p",[a._v("public static void main(String[] args) {")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('  DeadThread t1 = new DeadThread();\n\n   Thread ta = new Thread(t1, "A");\n\n   Thread tb = new Thread(t1, "B");\n\n   ta.start();\n\n   tb.start();\n')])])]),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("}")]),a._v(" "),t("p",[a._v("对应的dump：")]),a._v(" "),t("p",[a._v('"B" prio=10 tid=0x0898d000 nid=0x269a waiting for monitor entry [0x8baa2000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat org.marshal.DeadThread.method_A(DeadThread.java:11)\n- waiting to lock <0xaa4d6f88> (a java.lang.Object)\n- locked <0xaa4d6f80> (a java.lang.Object)\nat org.marshal.DeadThread.run(DeadThread.java:28)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v('"A" prio=10 tid=0x0898b800 nid=0x2699 waiting for monitor entry [0x8baf3000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat org.marshal.DeadThread.method_B(DeadThread.java:19)\n- waiting to lock <0xaa4d6f80> (a java.lang.Object)\n- locked <0xaa4d6f88> (a java.lang.Object)\nat org.marshal.DeadThread.run(DeadThread.java:29)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v("同时注意到，在stack trace尾部信息：")]),a._v(" "),t("h1",{attrs:{id:"found-one-java-level-deadlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#found-one-java-level-deadlock"}},[a._v("#")]),a._v(" Found one Java-level deadlock:")]),a._v(" "),t("p",[a._v('"B":\nwaiting to lock monitor 0x089615d8 (object 0xaa4d6f88, a java.lang.Object),\nwhich is held by "A"\n"A":\nwaiting to lock monitor 0x08962258 (object 0xaa4d6f80, a java.lang.Object),\nwhich is held by "B"')]),a._v(" "),t("h1",{attrs:{id:"java-stack-information-for-the-threads-listed-above"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-stack-information-for-the-threads-listed-above"}},[a._v("#")]),a._v(" Java stack information for the threads listed above:")]),a._v(" "),t("p",[a._v('"B":\nat org.marshal.DeadThread.method_A(DeadThread.java:11)\n- waiting to lock <0xaa4d6f88> (a java.lang.Object)\n- locked <0xaa4d6f80> (a java.lang.Object)\nat org.marshal.DeadThread.run(DeadThread.java:28)\nat java.lang.Thread.run(Thread.java:636)\n"A":\nat org.marshal.DeadThread.method_B(DeadThread.java:19)\n- waiting to lock <0xaa4d6f80> (a java.lang.Object)\n- locked <0xaa4d6f88> (a java.lang.Object)\nat org.marshal.DeadThread.run(DeadThread.java:29)\nat java.lang.Thread.run(Thread.java:636)')]),a._v(" "),t("p",[a._v("Found 1 deadlock.")]),a._v(" "),t("p",[a._v("stack中直接报告了Java级别的死锁。")]),a._v(" "),t("p",[a._v("也许这样直接看dump文件不太直观，建议使用ibm的javacode分析工具（附件）进行分析，如，以上会发生死锁的代码产生的dump文件放入到分析工具中显示如下：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/state.jpg",alt:""}})]),a._v(" "),t("p",[a._v("从图形界面我们更加容易定位问题，具体该工具的使用需要大家自己查找资料还有自己积累。")]),a._v(" "),t("p",[a._v("附件：javacode udmp 分析工具（执行 java -jar jca.jar即可打开）    jca.jar")]),a._v(" "),t("p",[a._v("参考资料：")]),a._v(" "),t("p",[a._v("http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html")]),a._v(" "),t("p",[a._v("http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html")]),a._v(" "),t("p",[a._v("http://www.linuxidc.com/Linux/2009-01/18171p2.htm")]),a._v(" "),t("p",[a._v("http://sesame.iteye.com/blog/428012")])])}),[],!1,null,null,null);e.default=r.exports}}]);