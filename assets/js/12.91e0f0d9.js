(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{503:function(o,c,r){"use strict";r.r(c);var t=r(4),e=Object(t.a)({},(function(){var o=this,c=o.$createElement,r=o._self._c||c;return r("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[r("h4",{attrs:{id:"powermockito详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#powermockito详解"}},[o._v("#")]),o._v(" PowerMockito详解")]),o._v(" "),r("ul",[r("li",[o._v("mock对象就是在调试期间用来作为真实对象的替代品")]),o._v(" "),r("li",[o._v("mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试")])]),o._v(" "),r("h4",{attrs:{id:"_1-为什么要使用mock工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要使用mock工具"}},[o._v("#")]),o._v(" 1. 为什么要使用Mock工具")]),o._v(" "),r("blockquote",[r("p",[o._v("在做单元测试的时候，我们会发现我们要测试的方法会引用很多外部依赖的对象，比如：（发送邮件，网络通讯，远程服务, 文件系统等等）。 而我们没法控制这些外部依赖的对象，因此在很快的时间内协调到外部资源，这样显然无法快速响应，那么您所负责的代码由于不具备单元测试环境没有办法进行测试，很可能存在极大的风险，因此如何测试您的代码，让代码的质量达到百分之百的可用，这就是 Mock 存在的必要。也因此为了解决这个问题，我们就需要用到Mock工具来模拟这些外部依赖的对象，来完成单元测试。")])]),o._v(" "),r("h4",{attrs:{id:"_2-为什么要使用powermock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么要使用powermock"}},[o._v("#")]),o._v(" 2. 为什么要使用PowerMock")]),o._v(" "),r("p",[o._v("在 Java 的 TDD 领域已经有如此多的 Mock 框架，比如 EasyMock，JMock，Mockito"),r("br"),o._v("\n为什么还要有 PowerMock 的存在，   上述三个都存在一个共同的缺点：不能mock静态、final、私有方法等，而powerMock能够完美的弥补以上三个mock工具的不足。")]),o._v(" "),r("h4",{attrs:{id:"_2-1-powermock解决了什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-powermock解决了什么问题"}},[o._v("#")]),o._v(" 2.1 PowerMock解决了什么问题")]),o._v(" "),r("p",[o._v("那么到底 PowerMock 解决了哪些问题，PowerMock 的官方文档说的非常的清楚，他"),r("br"),o._v("\n们解决了如下的问题.")]),o._v(" "),r("blockquote",[r("p",[o._v("PowerMock is a framework that extend other mock libraries such as EasyMock with more  powerful capabilities. PowerMock uses a custom classloader and bytecode manipulation to  enable mocking of static methods, constructors, final classes and methods, private methods,  removal of static initializers and more.")])]),o._v(" "),r("p",[o._v("使用过 EasyMock 或者 Mockito 的人应该非常清楚，他们两个无法完成对 final 类型"),r("br"),o._v("\n的 class 和 method 的 mock 操作，不能完成对类方法（static）的 mock，不能完成对局"),r("br"),o._v("\n部变量的 mock 等等，PowerMock 的出现就是为了解决诸如此类的问题，简言之就是专治"),r("br"),o._v("\n各种不服。")]),o._v(" "),r("h4",{attrs:{id:"_3-powermock简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-powermock简介"}},[o._v("#")]),o._v(" 3. PowerMock简介")]),o._v(" "),r("blockquote",[r("p",[o._v("PowerMock是一个扩展了其它如EasyMock等mock框架的、功能更加强大的框架。PowerMock使用一个自定义类加载器和字节码操作来模拟静态方法，构造函数，final类和方法，私有方法，去除静态初始化器等等。通过使用自定义的类加载器，简化采用的IDE或持续集成服务器不需要做任何改变。熟悉PowerMock支持的mock框架的开发人员会发现PowerMock很容易使用，因为对于静态方法和构造器来说，整个的期望API是一样的。PowerMock旨在用少量的方法和注解扩展现有的API来实现额外的功能。目前PowerMock支持EasyMock和Mockito。\n"),r("img",{attrs:{src:"/img/powermock.png",alt:"powermock"}}),o._v("\nPowerMock 主要围绕着 Junit 测试框架和 TestNg 测试框架进行，其中在每个框架下"),r("br"),o._v("\n面对所涉及的 Mock 框架仅仅支撑 EasyMock 和 Mockito，为什么要画这个图呢，是因为"),r("br"),o._v("\nPowerMock 对所依赖的 Jar 包非常的苛刻，如果出现某个依赖包的冲突或者不一致都会出"),r("br"),o._v("\n现不能使用的情况，因此根据您的喜好和擅长，请选择官网上提供的 PowerMock 套件，"),r("br"),o._v("\n这里采用的是 Junit+PowerMock+Mockito 这样的组合来进行讲述的。\n参考资料： https://github.com/powermock/powermock")])])])}),[],!1,null,null,null);c.default=e.exports}}]);