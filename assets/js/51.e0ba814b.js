(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{542:function(t,_,n){"use strict";n.r(_);var a=n(4),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,n=t._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h4",{attrs:{id:"mysql"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[t._v("#")]),t._v(" MySQL:")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("1.ddl:create创建、drop删除、alter修改等语句")]),t._v(" "),n("p",[t._v("example:")]),t._v(" "),n("h1",{attrs:{id:"创建一个学生表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建一个学生表"}},[t._v("#")]),t._v(" 创建一个学生表")]),t._v(" "),n("p",[t._v("CREATE TABLE students(\nstudent_id INT UNSIGNED,\nname VARCHAR(30),\nsex CHAR(1),\nbirth DATE,\nPRIMARY KEY (student_id)")]),t._v(" "),n("p",[t._v(");")])]),t._v(" "),n("li",[n("p",[t._v("2.dml：insert增、delete删、update改")]),t._v(" "),n("p",[t._v("example:\n#插入一条数据\nINSERT INTO students VALUES (1,'SKY','1','1992-09-09');")])]),t._v(" "),n("li",[n("p",[t._v("3.dql:select语句")]),t._v(" "),n("p",[t._v("example:查询语句\nSELECT t.* FROM test.students t LIMIT 501")])]),t._v(" "),n("li",[n("p",[t._v("4.DCL：grant\\commit\\rollback等语句")])])]),t._v(" "),n("h4",{attrs:{id:"数据库访问接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库访问接口"}},[t._v("#")]),t._v(" 数据库访问接口")]),t._v(" "),n("ul",[n("li",[t._v("ODBC")]),t._v(" "),n("li",[t._v("JDBC")]),t._v(" "),n("li",[t._v("ADO.NET")]),t._v(" "),n("li",[t._v("PDO")])]),t._v(" "),n("h4",{attrs:{id:"mysql的优势"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql的优势"}},[t._v("#")]),t._v(" mysql的优势")]),t._v(" "),n("ul",[n("li",[t._v("速度：运行速度快")]),t._v(" "),n("li",[t._v("价格：对多数个人开发者是免费的")]),t._v(" "),n("li",[t._v("容易使用：复杂度低，易用")]),t._v(" "),n("li",[t._v("可移植性：可跨平台，如Linux、Windows等")]),t._v(" "),n("li",[t._v("丰富的接口：提供了C++、java、php、python等api")]),t._v(" "),n("li",[t._v("支持的查询语言：支持标准sql语法和odbc的应用程序")]),t._v(" "),n("li",[t._v("安全性和连接性：灵活和安全的权限和密码系统，允许基于主机的验证。连接服务器时\n，所有的密码传输均采用加密的形式，从而保证密码安全。而且，可以在因特网上的任何地方\n访问，提供数据共享的效率。")]),t._v(" "),n("li",[t._v("支持json")]),t._v(" "),n("li",[t._v("性能和可扩展性：改进innoDB的可扩展性和临时表的性能，从而实现更快的网络和大数据\n加载等操作。")]),t._v(" "),n("li",[t._v("改进复制以提高可用性的性能")]),t._v(" "),n("li",[t._v("性能模式提供更好的视角：增强了许多监控功能")]),t._v(" "),n("li",[t._v("优化")]),t._v(" "),n("li",[t._v("GIS")])]),t._v(" "),n("h4",{attrs:{id:"mysql工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql工具"}},[t._v("#")]),t._v(" mysql工具")]),t._v(" "),n("ul",[n("li",[t._v("mysqld:sql后台程序，即MySQL服务进程")]),t._v(" "),n("li",[t._v("mysql_safe:服务器启动脚本")]),t._v(" "),n("li",[t._v("mysql.server:服务器启动脚本")]),t._v(" "),n("li",[t._v("......")])]),t._v(" "),n("h4",{attrs:{id:"mysql登录命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql登录命令"}},[t._v("#")]),t._v(" mysql登录命令")]),t._v(" "),n("ul",[n("li",[t._v("mysql -h localhost -u root -p   "),n("br"),t._v("\n-h：后面是主机地址\n-u:后面是用户名\n-p：后面跟的是密码")])]),t._v(" "),n("h4",{attrs:{id:"mysql的基本操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql的基本操作"}},[t._v("#")]),t._v(" mysql的基本操作")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("1.创建数据库")]),t._v(" "),n("p",[t._v("1.1 show DATABASES：查询当前存在的数据库\n1.2 创建数据库语法：\n#创建一个名为test_tb的数据库 CREATE DATABASE test_tb;\n1.3 使用SHOW CREATE DATABASE test_tb查看创建该数据库的定义，数据库创建信息\n1.4 查看当前数据库使用字符集：SHOW VARIABLES LIKE 'character_set_%'\n1.5 查看当前版本，select version()")])]),t._v(" "),n("li",[n("p",[t._v("2.删除数据库")]),t._v(" "),n("h1",{attrs:{id:"删除数据库-删除需谨慎-mysql不会给任何确认信息-直接干掉-且不能恢复"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除数据库-删除需谨慎-mysql不会给任何确认信息-直接干掉-且不能恢复"}},[t._v("#")]),t._v(" 删除数据库:删除需谨慎，mysql不会给任何确认信息，直接干掉，且不能恢复")]),t._v(" "),n("p",[t._v("DROP DATABASE  test_tb;")])]),t._v(" "),n("li",[n("p",[t._v("3.不同类型的数据存储引擎和存储引擎的选中")]),t._v(" "),n("ul",[n("li",[t._v("3.1数据库存储引擎是数据库底层的存储软件组件，DBMS数据库系统使用该存储引擎创建、查询、更新、删除数据操作。")]),t._v(" "),n("li",[t._v("3.2不同的存储引擎提供的存储机制、索引技巧、锁定水平都不同。")]),t._v(" "),n("li",[t._v("3.3 mysql中支持的存储引擎有：innoDB、myisam,memory,merge,archive,federated,csv等，mysql默认InnoDB存储引擎")]),t._v(" "),n("li",[t._v("3.4 可以使用 SHOW ENGINES #查看系统所支持的存储引擎")])])]),t._v(" "),n("li",[n("p",[t._v("4 各种存储引擎的区别对比")]),t._v(" "),n("p",[t._v("存储引擎\t支持\t   解释\t                                                            事务\tXA\tSavepoints\nInnoDB\tDEFAULT\t支持事务ACID、行级锁、外键\t                                        YES\tYES\tYES\nMRG_MYISAM\tYES\tCollection of identical MyISAM tables\t                        NO\tNO\tNO\nMEMORY\tYES\tHash based, stored in memory, useful for temporary tables\t        NO\tNO\tNO\nBLACKHOLE\tYES\t/dev/null storage engine (anything you write to it disappears)\tNO\tNO\tNO\nMyISAM\tYES\tMyISAM storage engine\t                                            NO\tNO\tNO\nCSV\tYES\tCSV storage engine\t                                                    NO\tNO\tNO\nARCHIVE\tYES\tArchive storage engine\t                                            NO\tNO\tNO\nPERFORMANCE_SCHEMA\tYES\tPerformance Schema\t                                    NO\tNO\tNO\nFEDERATED\tNO\tFederated MySQL storage engine")])]),t._v(" "),n("li",[n("p",[t._v("5.InnoDB")]),t._v(" "),n("ul",[n("li",[t._v("5.1 InnoDB是事务型数据库的首选，支持事务ACID,支持行锁定、外键。主要特性：")]),t._v(" "),n("li",[t._v("5.2 InnoDB具有提交、回滚、崩溃恢复能力的特性")]),t._v(" "),n("li",[t._v("5.3 InnoDB为处理海量数据的最大性能设计。它的CPU效率是其他基于磁盘的关系型数据库引擎所不能匹敌的。")]),t._v(" "),n("li",[t._v("5.4 InnoDB完全和mysql服务器整合，innoDB将表和索引存在一个逻辑表空间，表空间可以包含数个文件，而myisam中每个表被分在分离的文件中")]),t._v(" "),n("li",[t._v("5.5 InnoDB支持外键完整性约束，每张表的存储按照主键的顺序存放，如果没有显示的设置主键，那么将会为每一行生成一个6B的rowID,以此作为主键")]),t._v(" "),n("li",[t._v("5.6 innoDB被用在多数大型需要高性能的项目上")])])]),t._v(" "),n("li",[n("p",[t._v("6.MyISAM")]),t._v(" "),n("ul",[n("li",[t._v("6.1 基于isam扩展，拥有较高的查询、插入速度，但不支持事务。主要特性：")]),t._v(" "),n("li",[t._v("6.2 大文件在支持大文件的文件系统和操作系统被支持")]),t._v(" "),n("li",[t._v("6.3 当把删除插入查询操作混合使用时，动态尺寸的行产生更少的碎片")]),t._v(" "),n("li",[t._v("6.4 每张表最大索引数64，可以通过编译改变。每个索引最大列数是16个")]),t._v(" "),n("li",[t._v("6.5 最大的键长度1000B，可以通过编译改变。")]),t._v(" "),n("li",[t._v("6.6 blob和text可以被索引")]),t._v(" "),n("li",[t._v("6.7 NULL值允许在索引的列中")]),t._v(" "),n("li",[t._v("6.8 所有数字键值以高字节被存储以允许一个更高的索引压缩")]),t._v(" "),n("li",[t._v("6.9  每表一个自增列的内部处理。")]),t._v(" "),n("li",[t._v("6.10 可以把数据文件和索引文件存放在不同目录")]),t._v(" "),n("li",[t._v("6.11  每个字符列可以有不同的字符集")]),t._v(" "),n("li",[t._v("6.12   有varchar的表可以固定或者动态的记录长度，varchar和char列可以多达64KB   "),n("br"),t._v("\n使用myisam创建表，将产生3个文件，文件的名字以表的名字开始，扩展名指出文件类型，frm是存储表的定义，数据\n文件的扩展名为.myd(mydata)，索引文件的扩展名为.myi(.myindex)")])])]),t._v(" "),n("li",[n("p",[t._v("7.选择")]),t._v(" "),n("ul",[n("li",[t._v("7.1 如果需要提供提交、回滚、恢复能力的事务安全能力，并要求实现并发控制那么选择innoDB")]),t._v(" "),n("li",[t._v("7.2 如果数据仅以插入、更新记录，则选择myisam更好")]),t._v(" "),n("li",[t._v("7.3 如果仅临时存放数据，数据量不大，并且也不需要较高的安全性，可以选择将数据保存在内存中，选择memory引擎")]),t._v(" "),n("li",[t._v("7.4 如果只有insert和select操作，则选择archive引擎，该引擎支持高并发的插入操作，但不具有事务安全性，适合存放一些归档数据，如日志信息")])])])]),t._v(" "),n("h4",{attrs:{id:"数据表的基本操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据表的基本操作"}},[t._v("#")]),t._v(" 数据表的基本操作")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1.1 数据表属于数据库，创建表之前应先指定使用哪个数据库，即 USE <数据库名>\n1.2 创建数据表语法:\n        CREATE TABLE tb_empl(\n          id int(11) PRIMARY KEY COMMENT '员工编号' ,\n          name VARCHAR(20) COMMENT '员工姓名',\n          deptId int(11)  COMMENT '部门编号',\n          salary FLOAT COMMENT '工资'\n        )\n        \n1.3 主键约束；外键约束：不能跨引擎使用，为了确保数据的参照完整性。；非空约束；唯一约束：name VARCHAR(20) UNIQUE,指定该name列唯一，允许有空值，但仅限1个。唯一的约束保障1列或者几列不出现重复值\n1.4 唯一约束和主键约束的区别：主键约束不允许有空值，而且主键只允许1个；唯一约束可以有多个\n1.5 默认约束，即指定默认值，sex varchar(1) default '1'\n1.6 自增(AUTO_INCREMENT):id int(11) PRIMARY KEY AUTO_INCREMENT COMMENT '员工编号' ,\n1.7 插入：INSERT INTO tb_emp2 (name, deptId, salary) VALUES ('SKY','1234567890',100.00);\n1.8 查询表结构信息 :DESCRIBE tb_emp2或者DESC tb_emp2\n1.9 查询表创建时的详细信息：SHOW CREATE TABLE tb_emp2;\n1.10 修改数据表：\n     修改表名：ALTER TABLE 表名 RENAME 新表名  ； ALTER TABLE tb_emp2 RENAME tb_emp \n     修改表字段数据类型：ALTER TABLE 表名 MODIFY 字段名 字段数据类型 ；例如：ALTER TABLE tb_emp2 MODIFY id BIGINT \n     修改表字段名：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段数据类型; 例如：ALTER TABLE tb_emp CHANGE id EMP_ID BIGINT;\n     添加字段：ALTER TABLE 表名 ADD 新字段名 字段数据类型 ; 例如：ALTER TABLE tb_emp ADD address VARCHAR(20) DEFAULT '南京市';\n     删除字段：ALTER TABLE 表名 DROP 字段名;ALTER TABLE tb_emp DROP address;\n     指定字段排列首位：ALTER TABLE tb_emp MODIFY EMP_ID INT(11) FIRST ;\n     修改字段到表的指定列之后：ALTER TABLE tb_emp MODIFY 字段名 字段数据类型 AFTER 指定列名 ;  例如：ALTER TABLE tb_emp MODIFY deptId INT(11) AFTER name ;\n     更改表的存储引擎：ALTER TABLE 表名 ENGINE = 存储引擎; 例如：ALTER TABLE tb_emp ENGINE = MYISAM;\n     删除表的外键约束：ALTER TABLE tb_emp DROP FOREIGN KEY 'FOREIGN_KEY';\n     删除数据表：drop table IF EXISTS  表名     例如：DROP TABLE  IF EXISTS tb_test;\n")])])]),n("h4",{attrs:{id:"数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),n("p",[t._v("1.char和varchar之间的特点和选择：")]),t._v(" "),n("ul",[n("li",[t._v("char是固定长度字符，varchar是可变长度字符")]),t._v(" "),n("li",[t._v("char会自动删除尾部空格，而varchar不会")]),t._v(" "),n("li",[t._v("char是固定长度，占空间大，但处理速度较varchar快。"),n("br")])]),t._v(" "),n("p",[t._v("2.存储引擎对于选择char和varchar的选中")]),t._v(" "),n("ul",[n("li",[t._v("对于myisam而言，最好使用固定char代替可变长度的数据列，这样可以使整个表静态化，从而检索更快，用空间换时间")]),t._v(" "),n("li",[t._v("对于innoDB而言，使用可变varchar，因为innoDB存储格式不分固定长度和可变长度，因此使用char不一定比varchar要好，但由于varchar是根据实际的长度\n存储，比较节省空间，所以对磁盘I/O和数据存储总量比较好")])]),t._v(" "),n("h4",{attrs:{id:"查询数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#查询数据"}},[t._v("#")]),t._v(" 查询数据")]),t._v(" "),n("ul",[n("li",[t._v("分组，GROUP BY与HAVING联合使用，having作限定、过滤作用，只有满足条件的分组才会被统计\nSELECT name, sum(salary) GZ FROM tb_emp GROUP BY name HAVING COUNT(name)>1")])]),t._v(" "),n("h4",{attrs:{id:"插入、更新与删除数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#插入、更新与删除数据"}},[t._v("#")]),t._v(" 插入、更新与删除数据")]),t._v(" "),n("ul",[n("li",[t._v("将查询出的数据插入：  INSERT INTO t_test (id,userName) ( SELECT sum(salary),name FROM tb_emp GROUP BY name HAVING COUNT(name)>1)")])]),t._v(" "),n("h4",{attrs:{id:"索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[t._v("#")]),t._v(" 索引")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("1.什么是索引")]),t._v(" "),n("ul",[n("li",[t._v("1.1 索引是对数据库表中一列或者多列进行排序的一种数据结构，使用索引可提高数据库中特定数据的查询速度。")]),t._v(" "),n("li",[t._v("1.2 索引的含义和特点：索引是一个单独的、存储在磁盘上的数据库结构，他们有着对数据表所有记录的引用指针")]),t._v(" "),n("li",[t._v("1.3 索引是在存储引擎中实现的，因此每一种存储引擎的索引都不一定完全相同")]),t._v(" "),n("li",[t._v("1.4 mysql中索引的存储类型有两种：btree和hash,myisam和innoDB只支持btree索引，memory和heap存储引擎可以支持两种")]),t._v(" "),n("li",[t._v("1.5 索引的优点：\n"),n("ul",[n("li",[t._v("1.5.1 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性")]),t._v(" "),n("li",[t._v("1.5.2 可以大大加快查询速度")]),t._v(" "),n("li",[t._v("1.5.3 在实现数据的参考完整性方面，可以加速表与表之间的连接")]),t._v(" "),n("li",[t._v("1.5.4 在使用分组和排序子句进行查询的时候，可以显著减少查询中分组和排序的时间")])])]),t._v(" "),n("li",[t._v("1.6 索引的不良后果\n"),n("ul",[n("li",[t._v("1.6.1 创建索引和维护索引需要耗费时间，并且随着数据量的增加锁耗费的时间也会增加")]),t._v(" "),n("li",[t._v("1.6.2 索引也需要耗费磁盘空间，除了占据数据表空间之外，每一个索引还要占据一定的物理空间，如果有大量索引，索引文件可能比数据文件更快达到最大文件尺寸。")]),t._v(" "),n("li",[t._v("1.6.3 当对表中的数据进行增加、删除和修改的时候，索引也需要动态维护，这样就降低了数据的维护速度")])])]),t._v(" "),n("li",[t._v("1.7 索引的分类\n"),n("ul",[n("li",[t._v("1.7.1 唯一索引和普通索引 :唯一索引：唯一但允许有空值；普通索引：基本索引类型，允许有空值和重复值")]),t._v(" "),n("li",[t._v("1.7.2 单列索引和组合索引 :单列索引：一个索引只包含单个列，一个表可以有多个单列索引；组合索引：指在表的多个字段组合上创建索引，只有在查询时使用了这些字段的左边字段时才会生效，使用组合索引遵循最左前缀集合")]),t._v(" "),n("li",[t._v("1.7.3 全文索引 :该索引类型为fulltext，在定义索引的列上支持全文查找，允许这些列插入重复值和空值，全文索引可以在char和varchar或者text上创建，mysql中仅myisam支持全文索引")]),t._v(" "),n("li",[t._v("1.7.4 空间索引 :空间索引是对空间数据类型的字段建立的索引，创建空间索引的列，必须notnull，且仅支持myisam")])])]),t._v(" "),n("li",[t._v("1.8 索引的设计原则\n"),n("ul",[n("li",[t._v("1.8.1 索引并非越多越好，需要根据具体情况具体而用，因为一个表中如有大量索引，将占据大量磁盘空间，在删除、更新、插入时还需要维护，影响性能")]),t._v(" "),n("li",[t._v("1.8.2 避免对经常更新的表进行过多的索引，并且索引的列尽可能的少，而对经常用于查询的字段应该进行索引，但要避免不必要的字段")]),t._v(" "),n("li",[t._v("1.8.3 数据量小的表最好不要建立索引，由于数据少，查询花费的时间可能比遍历索引的时间还要短，索引不会产生优化效果")]),t._v(" "),n("li",[t._v("1.8.4 在频繁进行排序和分组的列上建立索引，如果待排列的列有多个，可在这些列上建立组合索引")]),t._v(" "),n("li",[t._v("1.8.5 当唯一性是某种数据本身的特征时，建立唯一索引。使用唯一索引需要确保定义的列的数据完整性，以提高查询速度。")]),t._v(" "),n("li",[t._v("1.8.6 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要使用索引。如：学生性别，sex,男女不同的值就无需建立索引。\n如果建立索引不但会提升查询速度，反而严重降低数据更新速度")])])])])]),t._v(" "),n("li",[n("p",[t._v("2.如何创建索引")]),t._v(" "),n("ul",[n("li",[t._v("2.1 添加普通索引 ALTER TABLE 表名 ADD INDEX 索引名(需要添加索引的字段)  例如：ALTER TABLE tb_emp ADD INDEX deptIdIndex(deptId)")]),t._v(" "),n("li",[t._v("2.2 添加唯一索引 ALTER TABLE 表名 ADD UNIQUE INDEX 索引名(需要添加索引的字段)  例如：ALTER TABLE tb_emp ADD UNIQUE INDEX deptIdIndex(deptId)")]),t._v(" "),n("li",[t._v("2.3 添加全文索引 CREATE FULLTEXT INDEX 索引名 ON 表名 (需要添加索引的字段); 如：CREATE FULLTEXT INDEX deptIdIndex2 ON tb_emp (name);")]),t._v(" "),n("li",[t._v("2.4 添加组合索引 CREATE INDEX 索引名 ON 表名 (字段1,字段2,字段3); 如：CREATE  INDEX deptIdIndex3 ON tb_emp (name,deptId,salary);")])])]),t._v(" "),n("li",[n("p",[t._v("3.如何删除索引")]),t._v(" "),n("ul",[n("li",[t._v("3.1 ALTER TABLE 表名 DROP INDEX 索引名; 如：ALTER TABLE tb_emp DROP INDEX deptIdIndex;")]),t._v(" "),n("li",[t._v("3.2")]),t._v(" "),n("li",[t._v("3.3")]),t._v(" "),n("li",[t._v("3.4")])])]),t._v(" "),n("li",[n("p",[t._v("4.熟悉操作索引的常见问题")])])]),t._v(" "),n("h4",{attrs:{id:"为什么你创建的数据库索引没有生效"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么你创建的数据库索引没有生效"}},[t._v("#")]),t._v(" 为什么你创建的数据库索引没有生效?")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("几乎所有的小伙伴都可以随口说几句关于创建索引的优缺点，也知道什么时候创\n建索引能够提高我们的查询性能，什么时候索引会更新，但是你有没有注意到，\n即使你设置了索引，有些时候索引他是不会生效的！这不仅考察了大家对索引的\n了解程度，还要让大家在使用的时候能够正确的使用。以下介绍了一些可能会造\n成索引失效的特殊情况，希望大家在平时开发和面试的时候能够注意到！\n")])])]),n("h4",{attrs:{id:"一、如何判断数据库索引是否生效"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、如何判断数据库索引是否生效"}},[t._v("#")]),t._v(" 一、如何判断数据库索引是否生效")]),t._v(" "),n("blockquote",[n("p",[t._v("首先在接着探讨之前，我们先说一下，如何判断数据库的索引是否生效！相信大\n家应该猜到了，就是explain！explain显示了MySQL如何使用索引来处理select\n语句以及连接表。他可以帮助选择更好的索引和写出更优化的查询语句。\n例如我们有一张表user，为name列创建索引name_index，如下所示：\n使用explain分析语句如下：\n可以看到，使用explain显示了很多列，各个关键字的含义如下：\ntable：顾名思义，显示这一行的数据是关于哪张表的；")])]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/explain.png",alt:"查看执行计划"}})]),t._v(" "),n("ul",[n("li",[n("font",{attrs:{color:"red"}},[t._v("type")]),t._v("：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型\n为：const、eq_reg、ref、range、indexhe和ALL；")],1),t._v(" "),n("li",[t._v("possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的\n索引。可以为相关的域从where语句中选择一个合适的语句；")]),t._v(" "),n("li",[t._v("key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，\nMySQL会选择优化不足的索引。这种情况下，可以在Select语句中使用USE")]),t._v(" "),n("li",[t._v("INDEX（indexname）来强制使用一个索引或者用IGNORE")]),t._v(" "),n("li",[t._v("INDEX（indexname）来强制MySQL忽略索引；")]),t._v(" "),n("li",[t._v("key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好；")]),t._v(" "),n("li",[n("font",{attrs:{color:"red"}},[t._v("ref")]),t._v("：显示索引的哪一列被使用了，如果可能的话，是一个常数；")],1),t._v(" "),n("li",[t._v("rows：MySQL认为必须检查的用来返回请求数据的行数；")]),t._v(" "),n("li",[t._v("Extra：关于MySQL如何解析查询的额外信息。")])]),t._v(" "),n("h4",{attrs:{id:"二、哪些场景会造成索引失效"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、哪些场景会造成索引失效"}},[t._v("#")]),t._v(" 二、哪些场景会造成索引失效")]),t._v(" "),n("ul",[n("li",[t._v("1、应尽量避免在 where 子句中使用 != 或 <> 操作符，否则引擎将放弃使用索\n引而进行全表扫描；")]),t._v(" "),n("li",[t._v("2、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索\n引而进行全表扫描，即使其中有条件带索引也不会使用，这也是为什么尽量少用\nor 的原因；")]),t._v(" "),n("li",[t._v("3、对于多列索引，不是使用的第一部分，则不会使用索引；")]),t._v(" "),n("li",[t._v("4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不\n会使用索引；")]),t._v(" "),n("li",[t._v("5、like的模糊查询以 % 开头，索引失效；")]),t._v(" "),n("li",[t._v("6、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用\n索引而进行全表扫描；")]),t._v(" "),n("li",[t._v("7、应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索\n引而进行全表扫描；")]),t._v(" "),n("li",[t._v("8、不要在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运\n算，否则系统将可能无法正确使用索引；")]),t._v(" "),n("li",[t._v("9、如果MySQL估计使用全表扫描要比使用索引快，则不使用索引；")]),t._v(" "),n("li",[t._v("10、不适合键值较少的列（重复数据较多的列）\n假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问\n表中的2000个数据块。再加上访问索引块，一共要访问大于200个的数据块。如\n果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全\n表扫描访问的数据块少一些，肯定就不会利用索引了。")])]),t._v(" "),n("h4",{attrs:{id:"mysql日志"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql日志"}},[t._v("#")]),t._v(" MySQL日志")]),t._v(" "),n("h4",{attrs:{id:"性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),n("ul",[n("li",[t._v("查询服务器慢查询次数\nSHOW STATUS  LIKE 'Slow_queries'")]),t._v(" "),n("li",[t._v("分析查询语句\nEXPLAIN  SELECT * FROM tb_emp;")])]),t._v(" "),n("h4",{attrs:{id:"索引规范"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#索引规范"}},[t._v("#")]),t._v(" 索引规范")]),t._v(" "),n("ol",[n("li",[t._v("索引的数量\n"),n("ol",[n("li",[t._v("单张表中索引数量不建议超过5个")]),t._v(" "),n("li",[t._v("单个索引中的字段数不超过5个")]),t._v(" "),n("li",[t._v("对字符串使用前缀索引，前缀索引长度不超过8个字符")])])]),t._v(" "),n("li",[t._v("主键准则\n"),n("ol",[n("li",[t._v("表必须有主键，没有合适的字段的话，写可以使用自增列作为主键")]),t._v(" "),n("li",[t._v("不使用更新频繁的列作为主键")]),t._v(" "),n("li",[t._v("尽量选择数值类型字段，不选择字符串字段")]),t._v(" "),n("li",[t._v("不使用UUID、MD5、HASH这些作为主键")])])]),t._v(" "),n("li",[t._v("重要的SQL必须被索引，如：\n"),n("ol",[n("li",[t._v("select、update、delete语句的where条件列")]),t._v(" "),n("li",[t._v("order by、group by、distinct字段")]),t._v(" "),n("li",[t._v("join的字段")])])]),t._v(" "),n("li",[t._v("多表JOIN的字段注意下以下几方面：\n"),n("ol",[n("li",[t._v("区分度最大的字段放在最前面")]),t._v(" "),n("li",[t._v("核心SQL优先考虑覆盖索引")]),t._v(" "),n("li",[t._v("避免冗余和重复索引")]),t._v(" "),n("li",[t._v("索引要综合评估数据密度和分布以及考虑查询和更新比例")]),t._v(" "),n("li",[t._v("JOIN应避免产生笛卡尔积")])])]),t._v(" "),n("li",[t._v("索引禁忌\n"),n("ol",[n("li",[t._v("不在低基数列上建立索引，例如：“性别”")]),t._v(" "),n("li",[t._v("不在索引列进行数学运算和函数运算")]),t._v(" "),n("li",[t._v("不在TEXT、BLOB字段上建立索引")])])]),t._v(" "),n("li",[t._v("禁止使用外键\n"),n("ol",[n("li",[t._v("外键用来保护数据参照完整性，在业务端实现")]),t._v(" "),n("li",[t._v("对父表和子表的操作会相互影响，降低可用性")])])]),t._v(" "),n("li",[t._v("索引命名\n"),n("ol",[n("li",[t._v("非唯一索引以 idx_字段1_字段2 命名")]),t._v(" "),n("li",[t._v("唯一索引以 uniq_字段1_字段2 命名")]),t._v(" "),n("li",[t._v("索引名称全部小写")])])]),t._v(" "),n("li",[t._v("新建的唯一索引不能和主键重复 。")]),t._v(" "),n("li",[t._v("索引字段必须设置为NOT NULL。")]),t._v(" "),n("li",[t._v("超过20个字符长度的字符串列，如需创建索引，可以考虑使用前缀索引。前缀索引的长度可以基于对该 字段的统计得出，一般略大于平均长度即可。")]),t._v(" "),n("li",[t._v("尽量使用复合索引，而不是添加新的索引；比如索引idx1(a, b)已经涵盖了索引idx2(a)，就可以考虑删除 idx2索引。")]),t._v(" "),n("li",[t._v("能使用唯一索引的一定要用唯一索引，提高查询效率。")]),t._v(" "),n("li",[t._v("开发人员需使用explain检查SQL效率。")]),t._v(" "),n("li",[t._v("MySQL索引的限制：")])]),t._v(" "),n("ul",[n("li",[t._v("MYSQL 目前不支持函数索引                             * 使用不等于 (!= 或者 <>) 的时候, MYSQL 无法使用索引")]),t._v(" "),n("li",[t._v("过滤字段使用单行函数 (如 abs (column)) 后, MYSQL无法使用索引")]),t._v(" "),n("li",[t._v("join语句中join条件字段类型不一致的时候MYSQL 无法使用索引")]),t._v(" "),n("li",[t._v("使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引\n*使用非等值查询的时候, MYSQL 无法使用 Hash 索引。  *  BLOB 和 TEXT 类型的列只能创建前缀索引")])]),t._v(" "),n("h4",{attrs:{id:"隔离级别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[t._v("#")]),t._v(" 隔离级别")]),t._v(" "),n("ul",[n("li",[t._v("read uncommited 能读取还未提交的事务，不能解决脏读、不可重复度和幻读")]),t._v(" "),n("li",[t._v("read commited  只能读取已经提交的事务，能解决脏读，不能解决不可重复读和幻读，一般使用此隔离级别")]),t._v(" "),n("li",[t._v("repeatable read  当一个事务读取这个数据时会对其进行加锁处理，防止其他事务对数据进行修改。重复读取(REPEATABLE_READ)的意思，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决")]),t._v(" "),n("li",[t._v("serlalizable 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("创建表t_test如下：\nCREATE TABLE `t_test` (\n  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键',\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '姓名',\n  `age` int DEFAULT NULL COMMENT '年龄',\n  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '性别',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='测试表';\n\n\n-- 开启事务1\t指定隔离级别：RU未提交读\t\t\t\t\t\t\t-- 开启事务2\t\t\t\t\t\t\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\t                SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\nbegin;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    begin;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\nUPDATE t_test SET name='new1' where id = 88;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\ncommit;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\n\n该种隔离级别下，事务1增删改但未提交的数据，事务2都是可见的，但是如果事务1再回滚，那么事务2读到的就是脏数据；该种隔离级别会出现：脏读、幻读、不可重复读。\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n-- 开启事务1\t指定隔离级别：RC提交读\t\t\t\t\t\t\t\t-- 开启事务2\t\t\t\t\t\t\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\t                \tSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nbegin;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    begin;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\nUPDATE t_test SET name='new1' where id = 88;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\ncommit;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\n\n该种隔离级别下，事务1增删改后提交的数据，事务2在该范围内前后两次查询结果不一致；该种隔离级别会出现：幻读、不可重复读。\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n-- 开启事务1\t指定隔离级别：RR可重复读\t\t\t\t\t\t\t-- 开启事务2\t\t\t\t\t\t\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ ;\t                SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nbegin;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    begin;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\ninsert into  t_test (id,name)  values ('1100','sky');\ncommit;\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUPDATE t_test SET name='new1' where id = 1100;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\n            \t\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\n\n该种隔离级别下，事务1增后提交的数据，事务2在该范围内，插入前查询不到，插入后却能更新成功，并且可以再次查询可以查询到数据，可见，幻读就是没有读到的记录，以为不存在，\n但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了；该种隔离级别会出现：幻读。\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n-- 开启事务1\t指定隔离级别：S\t\t\t\t\t\t\t\t\t\t-- 开启事务2\t\t\t\t\t\t\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\t                \tSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nbegin;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    begin;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\ninsert into  t_test (id,name)  values ('1100','sky');\ncommit;\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUPDATE t_test SET name='new1' where id = 1100;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT * FROM t_test where id = 88;\t\n            \t\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\n\n该种隔离级别下，serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。\n\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br"),n("span",{staticClass:"line-number"},[t._v("18")]),n("br"),n("span",{staticClass:"line-number"},[t._v("19")]),n("br"),n("span",{staticClass:"line-number"},[t._v("20")]),n("br"),n("span",{staticClass:"line-number"},[t._v("21")]),n("br"),n("span",{staticClass:"line-number"},[t._v("22")]),n("br"),n("span",{staticClass:"line-number"},[t._v("23")]),n("br"),n("span",{staticClass:"line-number"},[t._v("24")]),n("br"),n("span",{staticClass:"line-number"},[t._v("25")]),n("br"),n("span",{staticClass:"line-number"},[t._v("26")]),n("br"),n("span",{staticClass:"line-number"},[t._v("27")]),n("br"),n("span",{staticClass:"line-number"},[t._v("28")]),n("br"),n("span",{staticClass:"line-number"},[t._v("29")]),n("br"),n("span",{staticClass:"line-number"},[t._v("30")]),n("br"),n("span",{staticClass:"line-number"},[t._v("31")]),n("br"),n("span",{staticClass:"line-number"},[t._v("32")]),n("br"),n("span",{staticClass:"line-number"},[t._v("33")]),n("br"),n("span",{staticClass:"line-number"},[t._v("34")]),n("br"),n("span",{staticClass:"line-number"},[t._v("35")]),n("br"),n("span",{staticClass:"line-number"},[t._v("36")]),n("br"),n("span",{staticClass:"line-number"},[t._v("37")]),n("br"),n("span",{staticClass:"line-number"},[t._v("38")]),n("br"),n("span",{staticClass:"line-number"},[t._v("39")]),n("br"),n("span",{staticClass:"line-number"},[t._v("40")]),n("br"),n("span",{staticClass:"line-number"},[t._v("41")]),n("br"),n("span",{staticClass:"line-number"},[t._v("42")]),n("br"),n("span",{staticClass:"line-number"},[t._v("43")]),n("br"),n("span",{staticClass:"line-number"},[t._v("44")]),n("br"),n("span",{staticClass:"line-number"},[t._v("45")]),n("br"),n("span",{staticClass:"line-number"},[t._v("46")]),n("br"),n("span",{staticClass:"line-number"},[t._v("47")]),n("br"),n("span",{staticClass:"line-number"},[t._v("48")]),n("br"),n("span",{staticClass:"line-number"},[t._v("49")]),n("br"),n("span",{staticClass:"line-number"},[t._v("50")]),n("br"),n("span",{staticClass:"line-number"},[t._v("51")]),n("br"),n("span",{staticClass:"line-number"},[t._v("52")]),n("br"),n("span",{staticClass:"line-number"},[t._v("53")]),n("br"),n("span",{staticClass:"line-number"},[t._v("54")]),n("br"),n("span",{staticClass:"line-number"},[t._v("55")]),n("br"),n("span",{staticClass:"line-number"},[t._v("56")]),n("br"),n("span",{staticClass:"line-number"},[t._v("57")]),n("br"),n("span",{staticClass:"line-number"},[t._v("58")]),n("br"),n("span",{staticClass:"line-number"},[t._v("59")]),n("br"),n("span",{staticClass:"line-number"},[t._v("60")]),n("br"),n("span",{staticClass:"line-number"},[t._v("61")]),n("br"),n("span",{staticClass:"line-number"},[t._v("62")]),n("br"),n("span",{staticClass:"line-number"},[t._v("63")]),n("br"),n("span",{staticClass:"line-number"},[t._v("64")]),n("br"),n("span",{staticClass:"line-number"},[t._v("65")]),n("br"),n("span",{staticClass:"line-number"},[t._v("66")]),n("br")])]),n("h4",{attrs:{id:"事务的传播特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务的传播特性"}},[t._v("#")]),t._v(" 事务的传播特性")]),t._v(" "),n("blockquote",[n("p",[t._v("指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。")])]),t._v(" "),n("ul",[n("li",[t._v("1.PROPAGATION_REQUIRED  如果当前方法存在一个事务，则将该方法置于同一个事物中，如果之前不存在事务，则另新开启一个事物（delete ，insert update）")]),t._v(" "),n("li",[t._v("2.PROPAGATION_SUPPORTS 如果当前方法存在一个事务，则将该方法置于同一个事物中，如果之前不存在事务，则进行非事务执行（select）")]),t._v(" "),n("li",[t._v("3.PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。")]),t._v(" "),n("li",[t._v("4.PROPAGATION_REQUIRES_NEW 使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。\n它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起。")]),t._v(" "),n("li",[t._v("5.PROPAGATION_NOT_SUPPORTED PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。")]),t._v(" "),n("li",[t._v("6.PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。")]),t._v(" "),n("li",[t._v("7.PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行\n---获取数据库事务隔离级别:select @@global.tx_isolation;")])])])}),[],!1,null,null,null);_.default=s.exports}}]);